%% MASTER_AmplCorr.m
% runs amplitude cross-correlations on gamma events
% generated by MASTER_CollectGammaEvents
%
% Julien Catanese & Matthijs van der Meer

%% set paths
restoredefaultpath;
cd('D:\My_Documents\GitHub\fieldtrip');
ft_defaults;

rmpath('D:\My_Documents\GitHub\fieldtrip\external\signal\');

addpath(genpath('D:\My_Documents\GitHub\vandermeerlab\code-matlab\shared'));
addpath(genpath('D:\My_Documents\GitHub\vandermeerlab\code-matlab\tasks\Julien_linear_track')); % Detect events, CountCycles live here

%% load gamma events (use MASTER_CollectGammaEvents.m to obtain) -- puts ALL_evt variable in workspace
cd('D:\My_Documents\Dropbox\projects\Julien_multiLFP\2016-01-07');
%load(FindFile('gamma*.mat'));

%% define what to run
rats = {'R026','R032','R033','R039'};
PARAM.twin = 0.2; % half-width of time window to use for making trials (relative to event centers)
PARAM_f_label = {'lg','hg'};
PARAM_f_bandpass = {[45 65],[70 90]}; % frequency bands for event detection
PARAM_rankorder = 1;
PARAM_nShuffle = 1000; % if 0, don't run shuffles
debug = 0;

%%
available_rats = fieldnames(ALL_evt);
nRats = 0; nSessions = 0;

for iRat = 1:length(rats)
    
    this_rat = rats{iRat};
    
    if ~strmatch(this_rat,available_rats)
       warning('Rat %s not available -- skipping...',rats{iRat});
       continue;
    end
    
    available_sessions = fieldnames(ALL_evt.(this_rat));
    
    for iSession = 1:length(available_sessions)
    
        this_session = available_sessions{iSession};
        this_session_data = ALL_evt.(this_rat).(this_session);
        
        fprintf('\n\nProcessing session %s...\n',this_session);
        
        this_fd = this_session_data.fd;
        cd(this_fd);
        
        % load the data - ft version
        LoadExpKeys;
        
        cfg = [];
        cfg.fc = {ExpKeys.goodGamma_vStr{1},ExpKeys.goodGamma_PFC{1}};
        data = ft_read_neuralynx_interp(cfg.fc); % this will give many warnings, but is ok
        data.label = {'vStr','mPFC'};
        data.hdr.Fs = data.fsample; % we need this later -- should be set by ft_read_neuralynx_interp
        
        %%% add envelopes %%%
        % vStr
        temp_idx = strmatch('vStr',data.label,'exact');
        data_tsd = tsd(data.time{1},data.trial{1}(temp_idx,:));
        data_tsd.cfg.hdr{1}.SamplingFrequency = data.fsample;
        data_tsd.data(isnan(data_tsd.data)) = 0;
        
        cfg = [];
        cfg.f = PARAM_f_bandpass{1};
        cfg.type = 'cheby1'; cfg.order = 5;
        data_temp = FilterLFP(cfg,data_tsd); % filter
        data_temp = abs(hilbert(data_temp.data));
        if PARAM_rankorder, data_temp = tiedrank(data_temp); end
        
        data.label{3} = 'vStr-lg';
        data.trial{1}(3,:) = data_temp;
        
        cfg.f = PARAM_f_bandpass{2};
        data_temp = FilterLFP(cfg,data_tsd); % filter
        data_temp = abs(hilbert(data_temp.data));
        if PARAM_rankorder, data_temp = tiedrank(data_temp); end
        
        data.label{4} = 'vStr-hg';
        data.trial{1}(4,:) = data_temp;
        
        % mPFC
        temp_idx = strmatch('mPFC',data.label,'exact');
        data_tsd = tsd(data.time{1},data.trial{1}(temp_idx,:));
        data_tsd.cfg.hdr{1}.SamplingFrequency = data.fsample;
        data_tsd.data(isnan(data_tsd.data)) = 0;
        
        cfg = [];
        cfg.f = PARAM_f_bandpass{1};
        cfg.type = 'cheby1'; cfg.order = 5;
        data_temp = FilterLFP(cfg,data_tsd); % filter
        data_temp = abs(hilbert(data_temp.data));
        if PARAM_rankorder, data_temp = tiedrank(data_temp); end
        
        data.label{5} = 'mPFC-lg';
        data.trial{1}(5,:) = data_temp;
        
        cfg.f = PARAM_f_bandpass{2};
        data_temp = FilterLFP(cfg,data_tsd); % filter
        data_temp = abs(hilbert(data_temp.data));
        if PARAM_rankorder, data_temp = tiedrank(data_temp); end
        
        data.label{6} = 'mPFC-hg';
        data.trial{1}(6,:) = data_temp;
        
        %%% remove cross-labeled events
        this_lg = DifferenceIV([],this_session_data.lg,this_session_data.hg);
        this_hg = DifferenceIV([],this_session_data.hg,this_session_data.lg);
        
        %%% trialify %%%
        hg_t = IVcenters(this_hg);
        lg_t = IVcenters(this_lg);
        
        % lg
        cfg = [];
        cfg.t = lg_t - this_session_data.firstTimestamp;
        cfg.twin = [-PARAM.twin PARAM.twin];
        cfg.hdr = data.hdr;
        
        trl = ft_maketrl(cfg);
        
        cfg = [];
        cfg.trl = trl;
        data_trl_lg = ft_redefinetrial(cfg,data);
        
        % hg
        cfg = [];
        cfg.t = hg_t - this_session_data.firstTimestamp;
        cfg.twin = [-PARAM.twin PARAM.twin];
        cfg.hdr = data.hdr;
        
        trl = ft_maketrl(cfg);
        
        cfg = [];
        cfg.trl = trl;
        data_trl_hg = ft_redefinetrial(cfg,data);
        
        % inspect
        if debug
            ft_databrowser([],data_trl_lg);
        end
        
        % compute correlations
        clear pc_shift_lg pc_shift_hg shuf_lg_maxcorr_sd shuf_hg_maxcorr_sd 
    
        for iT = length(data_trl_lg.trial):-1:1
            
            temp_idx = strmatch('vStr-lg',data_trl_lg.label,'exact');
            vStr_lg = data_trl_lg.trial{iT}(temp_idx,:); vStr_lg = vStr_lg - nanmean(vStr_lg);
  
            temp_idx = strmatch('mPFC-lg',data_trl_lg.label,'exact');
            mPFC_lg = data_trl_lg.trial{iT}(temp_idx,:); mPFC_lg = mPFC_lg - nanmean(mPFC_lg);
                    
            [pc_shift_lg(iT,:),shift_values] = xcov(vStr_lg,mPFC_lg,100,'coeff');
            
            if PARAM_nShuffle > 0
               clear shuf_max_xcov_lg;
               
               for iShuf = PARAM_nShuffle:-1:1
                   %temp_whitenoise = rand(size(vStr_lg))-0.5;
                   temp_whitenoise = AUX_shuffle_phases(mPFC_lg);
                   temp_corrvalues = xcov(vStr_lg,temp_whitenoise,100,'coeff');
                   shuf_max_xcov_lg(iShuf) = max(temp_corrvalues);
               end
               
               shuf_lg_maxcorr_sd(iT) = std(shuf_max_xcov_lg);
            end
           
        end
        
        for iT = length(data_trl_hg.trial):-1:1
            
            temp_idx = strmatch('vStr-hg',data_trl_hg.label,'exact');
            vStr_hg = data_trl_hg.trial{iT}(temp_idx,:); vStr_hg = vStr_hg - nanmean(vStr_hg);

            temp_idx = strmatch('mPFC-hg',data_trl_hg.label,'exact');
            mPFC_hg = data_trl_hg.trial{iT}(temp_idx,:); mPFC_hg = mPFC_hg - nanmean(mPFC_hg);
                      
            [pc_shift_hg(iT,:),shift_values] = xcov(vStr_hg,mPFC_hg,100,'coeff');
            
            if PARAM_nShuffle > 0
               clear shuf_max_xcov_hg;
               
               for iShuf = PARAM_nShuffle:-1:1
                   %temp_whitenoise = rand(size(vStr_hg))-0.5;
                   temp_whitenoise = AUX_shuffle_phases(mPFC_hg);
                   temp_corrvalues = xcov(vStr_hg,temp_whitenoise,100,'coeff');
                   shuf_max_xcov_hg(iShuf) = max(temp_corrvalues);
               end
               
               shuf_hg_maxcorr_sd(iT) = std(shuf_max_xcov_hg);
            end
            
        end
       
        % add to all
        ALL_evt.(this_rat).(this_session).xcorr.lg = pc_shift_lg;
        ALL_evt.(this_rat).(this_session).xcorr.hg = pc_shift_hg;
        ALL_evt.(this_rat).(this_session).xcorr.shift_values = shift_values;
        
        if PARAM_nShuffle > 0
            ALL_evt.(this_rat).(this_session).xcorr.shuf_hg_maxcorr_sd = shuf_hg_maxcorr_sd;
            ALL_evt.(this_rat).(this_session).xcorr.shuf_lg_maxcorr_sd = shuf_lg_maxcorr_sd;
        end
        
    end % loop over sessions
            
end % loop over rats